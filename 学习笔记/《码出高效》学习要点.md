## 《码出高效》学习要点

#### **一、编程规约** 

##### 1、命名风格

##### 2、常量定义

> 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解。

##### 3、代码格式

> 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。

> 【强制】任何二目、三目运算符的左右两边都需要加一个空格。

> 【强制】缩进采用 4 个空格，禁止使用 tab 字符。

> 【强制】注释的双斜线与注释内容之间有且仅有一个空格。

##### 4、OOP规约

> 【强制】不能使用过时的类或方法。

> 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。
>
> 说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在
>
> IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行
>
> 判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，
>
> 推荐使用 equals 方法进行判断。

> 关于基本数据类型与包装数据类型的使用标准如下：
>
> 1） 【强制】所有的 POJO 类属性必须使用包装数据类型。
>
> 2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。
>
> <!--数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。-->
>
> 3） 【推荐】所有的局部变量使用基本数据类型。

> 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。

> 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source> generate toString
>
> 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。

> 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。

##### 5、集合处理

> 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。

原因：简单总结一下，之所以会抛出ConcurrentModificationException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示用户，可能发生了并发修改！https://developer.aliyun.com/article/756753



> 【推荐】集合初始化时，指定集合初始值大小。

> initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loader 
>
> factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。



> 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。
>
> 说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出
>
> key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效
>
> 率更高。如果是 JDK8，使用 Map.foreach 方法。
>
> 正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是
>
> 一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。

##### 6、并发处理

##### 7、控制语句

> 1. 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程
>
> 序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且
>
> 放在最后，即使它什么代码也没有。

> 2. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：
>
> if (condition) { 
>
>  ... 
>
>  return obj; 
>
> } 
>
> // 接着写 else 的业务逻辑代码; 
>
> 说明：如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。
>
> 正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，
>
> 其中卫语句示例如下：
>
> public void today() {
>
>  if (isBusy()) {
>
> System.out.println(“change time.”);
>
>  return;
>
>  }
>
>  if (isFree()) {
>
> System.out.println(“go to travel.”);
>
>  return;
>
>  }

> 3. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复
>
> 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。

#### 二、异常日志

> 1. 【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该
>
> 通过 catch 来处理，比如：IndexOutOfBoundsException，NullPointerException 等等。
>
> 说明：无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch
>
> NumberFormatException 来实现。
>
> 正例：if (obj != null) {...}
>
> 反例：try { obj.method() } catch (NullPointerException e) {...}

> 2. 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回
>
> 滚事务。

#### 三、单元测试

#### 四、安全规约

#### 五、MySql数据库

##### 1、建表规约

> 1. 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint
>
> （ 1 表示是，0 表示否）。
>
> 说明：任何字段如果为非负数，必须是 unsigned。
>
> 正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。

> 2. 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只
>
> 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。

> 3. 【强制】表名不使用复数名词。

> 4. 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。

> 5. 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。
>
> 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。

> 6. 【强制】小数类型为 decimal，禁止使用 float 和 double。
>
> 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不
>
> 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。

> 8. 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长
>
> 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索
>
> 引效率。

> 9. 【强制】表必备三字段：id, gmt_create, gmt_modified。
>
> 说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, 
>
> gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被
>
> 动更新。在navicat中无符号，在默认

##### 2、索引规约

> 1. 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
>
> 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明
>
> 显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必
>
> 然有脏数据产生

> 3. 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据
>
> 实际文本区分度决定索引长度即可。

> 4. 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
>
> 说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索
>
> 引。

> 8. 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts
>
> 最好。

> 9. 【推荐】建组合索引的时候，区分度最高的在最左边。
>
> 正例：如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即
>
> 可。
>
> 说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a>? 
>
> and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。

##### 3、SQL语句

> 1. 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的
>
> 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
>
> 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。

> 2. 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct
>
> col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。

> 3. 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为
>
> NULL，因此使用 sum()时需注意 NPE 问题。
>
> 正例：可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g))
>
> FROM table;

> 4. 【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。

> 5. 【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。

> 6. 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

> 8. 【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执 
>
> 行更新语句。

##### 4、ORM映射

> 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
>
> 说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。

> 2. 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行
>
> 字段与属性之间的映射。

> 3. 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需
>
> 要定义；反过来，每一个表也必然有一个与之对应。
>
> 说明：配置映射关系，使字段与 DO 类解耦，方便维护。

> 7. 【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。
